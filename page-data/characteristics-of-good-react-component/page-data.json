{"componentChunkName":"component---src-templates-blog-post-js","path":"/characteristics-of-good-react-component/","webpackCompilationHash":"352f8472a14b4023922c","result":{"data":{"site":{"siteMetadata":{"title":"Casual Cognitions","author":"Andrew Usher"}},"mdx":{"frontmatter":{"title":"Characteristics of Good React Component","date":"September 24, 2019"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Characteristics of Good React Component\",\n  \"date\": \"2019-09-24\",\n  \"published\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"\\u201CSingle responsibility\\u201D\\nA component has a single responsibility when it has one reason to change.\")), mdx(\"p\", null, \"An fundamental rule to consider when writing React components is the single responsibility principle.\"), mdx(\"p\", null, \"Single responsibility principle (abbreviated SRP) requires a component to have one reason to change.\"), mdx(\"p\", null, \"A component has one reason to change when it implements one responsibility, or simpler when it does one thing.\"), mdx(\"p\", null, \"A responsibility is either to render a list of items, or to show a date picker, or to make an HTTP request, or to draw a chart, or to lazy load an image, etc. Your component should pick only one responsibility and implement it. When you modify the way component implements its responsibility (e.g. a change to limit the number of items for render a list of items responsibility) - it has one reason to change.\"), mdx(\"p\", null, \"Why is it important to have only one reason to change? Because component\\u2019s modification becomes isolated and under control.\"), mdx(\"p\", null, \"Having one responsibility restricts the component size and makes it focused on one thing. A component focused on one thing is convenient to code, and later modify, reuse and test.\"), mdx(\"p\", null, \"Let\\u2019s follow a few examples.\"), mdx(\"p\", null, \"Example 1 A component fetches remote data, correspondingly it has one reason to change when fetch logic changes.\\nA reason to change happens when:\"), mdx(\"p\", null, \"The server URL is modified\\nThe response format is modified\\nYou want to use a different HTTP requests library\\nOr any modification related to fetch logic only.\\nExample 2 A table component maps an array of data to a list of row components, as result having one reason to change when mapping logic changes.\\nA reason to change occurs when:\"), mdx(\"p\", null, \"You have a task to limit the number of rendered row components (e.g. display up to 25 rows)\\nYou\\u2019re asked to show a message \\u201CThe list is empty\\u201D when there are no items to display\\nOr any modification related to mapping of array to row components only.\\nDoes your component have many responsibilities? If the answer is yes, split the component into chunks by each individual responsibility.\"), mdx(\"p\", null, \"An alternative reasoning about the single responsibility principle says to create the component around a clearly distinguishable axis of change. An axis of change attracts modifications of the same meaning.\\nIn the previous 2 examples, the axis of change were fetch logic and mapping logic.\"), mdx(\"p\", null, \"If you find SRP a bit obscured, check out this article.\"), mdx(\"p\", null, \"Units written at early project stage will change often until reaching the release stage. These change often\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/characteristics-of-good-react-component/","previous":{"id":"2157aa90-ce4e-540b-b225-76ba914c926b","fields":{"slug":"/adopting-testing/"},"frontmatter":{"title":"Adopting Testing"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Adopting Testing\",\n  \"date\": \"2019-09-20\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Tests are one of those things that everyone agrees is a good idea, yet many teams still don\\u2019t do. If you find yourself in one of those teams, don\\u2019t despair! In my experience, changing team culture to write test comes down to a simple idea: make it easier to write tests than to not write tests. I realize this may sound impossible since tests take time and effort, but this can be achieved in a few steps:\"), mdx(\"h3\", null, \"Make your test framework awesome\"), mdx(\"p\", null, \"Everyone tends to agree with the idea that test coverage is a good thing, but a lot of the pushback around writing tests is that it\\u2019s a pain. If your team has never worked with a good test setup, then writing tests can feel like an endless slog. You end up fighting battles with mock dependencies and hacky workarounds just to end up with a brittle test that nobody understands. Spend some time and make your test setup a pleasure to use, and focus on the developer experience. This may mean writing what look more like functional rather than pure unit tests - that\\u2019s fine! Test at the level that\\u2019s easiest and clearest to work with.\"), mdx(\"h3\", null, \"Be the change you wish to see in the codebase\"), mdx(\"p\", null, \"For developers that aren\\u2019t accustomed to writing tests it\\u2019s not always obvious how to begin to integrate tests into their workflow. Here, you can lead by example, by adding tests to all the new code you write. The best documentation on how to write tests for your codebase is for there to already be a slew of tests written that other developers can refer to. In addition, working test coverage into your own workflow is an excellent model for the rest of the team, and will help iron out any issues in the test system.\"), mdx(\"h3\", null, \"Ask for tests in code review\"), mdx(\"p\", null, \"Now that you\\u2019ve improved the test-writing experience, and modeled good test coverage in your own code, it\\u2019s time to start asking that other developers write tests as well. An easy way to do this is to simply ask other developers to add tests to their code in code-review. Hopefully, at this point, adding test coverage to pull requests should be less work than coming up with a reason not to given steps 1 and 2, and, afterall, everyone agrees it\\u2019s a good idea. Hopefully, the culture of the team should now begin to change towards writing tests as part of the normal flow. Once other developers start asking for test coverage in their code reviews as well that\\u2019s a good sign the culture change has stuck.\"), mdx(\"p\", null, \"You can also use tools like codecov or coveralls to automatically track test coverage in pull requests, and even fail builds that don\\u2019t meet a certain threshold.\"), mdx(\"p\", null, \"As testing becomes part of the team\\u2019s normal flow, and the codebase begins to have more and more tests written, the benefits of testing become obvious. There are fewer bugs, and developers begin to feel more comfortable refactoring and improving the existing code. It\\u2019s easy to just rip parts of the codebase out and refactor because you know the tests have your back. It becomes almost terrifying to imagine going back to before the code had tests (how did we do anything back then!?).\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":null}}}