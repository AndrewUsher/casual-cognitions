{"componentChunkName":"component---src-templates-blog-post-js","path":"/advice-for-kid-me/","webpackCompilationHash":"115c318475c32b7c029a","result":{"data":{"site":{"siteMetadata":{"title":"Casual Cognitions","author":"Andrew Usher"}},"mdx":{"frontmatter":{"title":"Advice For Me 10 Years Ago","date":"May 29, 2018"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Advice For Me 10 Years Ago\",\n  \"date\": \"2018-05-29\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Just follow your passion. I think working in different environments is very important. It helps you to gain experience and find your interests and passions. Looking back, it makes a lot of sense, but I would have never imagined where I would end up.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/advice-for-kid-me/","previous":{"id":"930dea2a-85b2-5dbf-9439-eb75ed6170a0","fields":{"slug":"/es2018-regex/"},"frontmatter":{"title":"Regular Expression Additions in ES 2018"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Regular Expression Additions in ES 2018\",\n  \"date\": \"2018-05-24\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Javascript has really come a long way in the past couple of years. With the now yearly updates of the language, there is always a lot of new things to learn. Something that is being added in 2018 is major improvements to regular expressions in JavaScript.\"), mdx(\"p\", null, \"If you are a complete beginner to regular expressions, this article can widen your understanding of the practical use of regular expressions. If, however, you do have at least an average knowledge of regular expressions, this article can get you caught up with new capabilities of regular expressions in JS.\"), mdx(\"h2\", null, \"Is Regex Finally Powerful In JS?\"), mdx(\"p\", null, \"It doesn\\u2019t have everything under the regex sun now, but JS has significantly closed the gap between its own engine and other PCRE-based regex engines. The new updates are geared towards practical use cases:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dotall Flag\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Named Capture Groups\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unicode Escapes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lookbehinds\")), mdx(\"h3\", null, \"Dotall Flag\"), mdx(\"p\", null, \"This is a pretty simple update that was added. In Javascript and many other PCRE regular expressions, newline characters like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\n\"), \" does not match the dot.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Newline character does not match dot\\nconst regex = /./.regex.test('\\\\n')\\n// > false\\n\")), mdx(\"p\", null, \"When we test it, the test returns false. However, adding an s flag in ES2018 matches the newline character in addition to the carriage return, line seperator, and paragraph seperator characters:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Dotall flag\\nlet regex = /./s\\nregex.test('\\\\n')\\n// > true\\nregex.test('\\\\r')\\n// > true\\nregex.test('\\\\u2028')\\n// > true\\nregex.test('\\\\u2029')\\n// > true\\n\")), mdx(\"h3\", null, \"Named Capture Groups\"), mdx(\"p\", null, \"Suppose you want to get the currency, numeric price value, and total currency in a string of format:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"Total: $60.00\\n\")), mdx(\"p\", null, \"The regular matching this string would look like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \";/^Total: [\\u20AC$]\\\\d\\\\d\\\\.\\\\d\\\\d$/\\n\")), mdx(\"p\", null, \"The dolloar sign and dot are escaped because they are metasyntax characters. After adding parentheses to capture the needed values, the regular expression lookis like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \";/^Total: (([\\u20AC$])(\\\\d\\\\d\\\\.\\\\d\\\\d))$/\\n\")), mdx(\"p\", null, \"We now have three capture groups to access the data:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1: price with currency\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"2: currency symbol\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"3: numeric price\")), mdx(\"p\", null, \"Using the indices 1, 2, and 3 to refer to these capture groups isn\\u2019t very maintainable. For example, what if price is multilingual, and you have to capture the Total as well:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \";/^(Total|Totaal): (([\\u20AC$])(\\\\d\\\\d\\\\.\\\\d\\\\d))$/\\n\")), mdx(\"p\", null, \"As a result, capture groups 1, 2, and 3 have now become 2, 3, and 4. Code processing these values now have to be rewritten. Enter capture groups:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"<\", \"priceWithSymbol\", \">\", \": price with symbol\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"<\", \"symbol\", \">\", \": currency symbol\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"<\", \"price\", \">\", \": numeric price\")), mdx(\"p\", null, \"The syntax \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<captureGroupName>content\"), \" matches \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"content\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<captureGroupName>\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Capture groups example\\nconst regex = /^Total: (?<priceWithSymbol>(?<symbol>[\\u20AC$])(?<price>\\\\d\\\\d\\\\.\\\\d\\\\d))$/\\n\")), mdx(\"p\", null, \"In order to create a named capture, all that\\u2019s needed is to write a question mark after the start of the parentheses, then the capture group name inside greater than and less than symbols.\"), mdx(\"p\", null, \"Now we\\u2019re done. Let\\u2019s see the results:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Named capture groups example\\nconst regex = /^Total: (?<priceWithSymbol>(?<symbol>[\\u20AC$])(?<price>\\\\d\\\\d\\\\.\\\\d\\\\d))$/\\nregex.exec('Total: $60.00').groups\\n// > {priceWithSymbol: $60.00, symbol: '$', price: '60.00'}\\n\")), mdx(\"p\", null, \"Named capture groups make regular expressions more maintainable.\"), mdx(\"h3\", null, \"Unicode Escapes\"), mdx(\"p\", null, \"This new feature is very documentation-heavy since the docs themselves discuss every minute detail in this update. You can use the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/tc39/proposal-regexp-unicode-property-escapes\"\n  }), \"documentation\"), \" as a reference. The documentation entails how you can match certain unicode character groups with some expressions without third party libraries. In this section, I\\u2019ll concentrate on some practical use cases of the addition instead of a thorough walkthrough of all unicode groups.\"), mdx(\"p\", null, \"One use case is matching greek characters. Before ES2018, you would have to create character sets:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Greek lowercase character set\\nconst greekChars = /[\\u03B8\\u03C9\\u03B5\\u03C1\\u03C4\\u03C8\\u03C5\\u03B9\\u03BF\\u03C0\\u03B1\\u03C3\\u03B4\\u03C6\\u03B3\\u03B7\\u03C2\\u03BA\\u03BB\\u03B6\\u03C7\\u03BE\\u03C9\\u03B2\\u03BD\\u03BC\\u03AC\\u03AD\\u03AE\\u03AF\\u03CA\\u0390\\u03CC\\u03CD\\u03CB\\u03B0\\u03CE]/u\\ngreekChars.test('\\u03BB')\\n// > true\\n\")), mdx(\"p\", null, \"That doesn\\u2019t even include uppercase letters:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const uppercaseGreekChars = /[\\u0398\\u03A9\\u0395\\u03A1\\u03A4\\u03A8\\u03A5\\u0399\\u039F\\u03A0\\u0391\\u03A3\\u0394\\u03A6\\u0393\\u0397\\u03C2\\u039A\\u039B\\u0396\\u03A7\\u039E\\u03A9\\u0392\\u039D\\u039C\\u0386\\u0388\\u0389\\u038A\\u03AA\\u0390\\u038C\\u038E\\u03AB\\u03B0\\u038F]/u\\nuppercaseGreekChars.test('\\u039B')\\n// > true\\n\")), mdx(\"p\", null, \"In ES2018, it\\u2019s a lot simpler:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Old way\\nconst greekChars = /[\\u03B8\\u03C9\\u03B5\\u03C1\\u03C4\\u03C8\\u03C5\\u03B9\\u03BF\\u03C0\\u03B1\\u03C3\\u03B4\\u03C6\\u03B3\\u03B7\\u03C2\\u03BA\\u03BB\\u03B6\\u03C7\\u03BE\\u03C9\\u03B2\\u03BD\\u03BC\\u03AC\\u03AD\\u03AE\\u03AF\\u03CA\\u0390\\u03CC\\u03CD\\u03CB\\u03B0\\u03CE]/u\\nconst uppercaseGreekChars = /[\\u0398\\u03A9\\u0395\\u03A1\\u03A4\\u03A8\\u03A5\\u0399\\u039F\\u03A0\\u0391\\u03A3\\u0394\\u03A6\\u0393\\u0397\\u03C2\\u039A\\u039B\\u0396\\u03A7\\u039E\\u03A9\\u0392\\u039D\\u039C\\u0386\\u0388\\u0389\\u038A\\u03AA\\u0390\\u038C\\u038E\\u03AB\\u03B0\\u038F]/u\\n// New way\\nconst unicodeEscape = /\\\\p{Script=Greek}/u\\nunicodeEscape.test('\\u03C0')\\n// > true\\nunicodeEscape.test('\\u03C9')\\n// > true\\nunicodeEscape.test('\\u03AB')\\n// > true\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/\\\\p{Script=Greek}/u\"), \" only matches Greek characters, and this is great semantic shorthand. If you think about it, Greek is very much like English in terms of the limited number of characters. In addition, you would have a have a difficult time working in Chinese or Japanese, where you would have to concatenate another endlees pool of symbols. This problem is solved with Unicode escapes in ES2018.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/\\\\p{Alphabetic}/u\"), \" matches any alphabetical character of any language:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Alphabetic unicode escape\\nconst regex = /\\\\p{Alphabetic}/u\\nregex.test('\\xE1')\\n// > true\\nregex.test('\\u304C')\\n// > true\\nregex.test('6')\\n// > false\\nregex.test('\\u03C0')\\n// > true\\nregex.test('\\u03C9')\\n// > true\\nregex.test('\\u03AB')\\n// > true\\n\")), mdx(\"h3\", null, \"Lookbehinds\"), mdx(\"p\", null, \"A lookbehind is the opposite of a lookahead. It walks backwards in the regular expression and checks if the given pattern matches the string before the current position. If a lookbehind match is succesful, the match is reverted.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Negative lookbehind: (?<!pattern)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Positive lookbehind: (?<=pattern)\")), mdx(\"p\", null, \"An implicit lookbehind does exist before ES2018, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\\\b\"), \", the word boundary anchor. So, in practice, you could use word boundaries without lookbehinds. Here are some examples that show this.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example 1\"), \": Determine if the string contains a character sequence starting with whimper or whisper:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const regex = /\\\\bwhi[ms]per/\\nregex.test(string)\\n\")), mdx(\"p\", null, \"In the example above, we\\u2019re looking for the pattern \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"whi[ms]per\"), \" in the string provided. Before the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w\"), \" character, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\b\"), \" word boundary anchor filters our results by ensuring a non-whitespace character cannot stand in front of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example 2\"), \": Here are some examples for negative and positive lookbehinds. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/(?<=e)i/\"), \" matches an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" character if it comes right after an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"e\"), \" character. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"e\"), \" character is not included in the match.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Positive lookbehind syntax\\nconst regex = /(?<=e)i/\\nregex.exec('oi')\\n// > null\\nregex.exec('ei')\\n// > {'i', index: 1, input: 'ei', groups: undefined}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/(?<=e)i/\"), \" matches an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" character if it does not come right after an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"e\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Negative lookbehind syntax\\nconst regex = /(?<=e)i/\\nregex.exec('oi')\\n// > {'i', index: 1, input: 'ei', groups: undefined}\\nregex.exec('ei')\\n// > null\\n\")), mdx(\"button\", {\n    onClick: function onClick() {\n      alert('Hi');\n    }\n  }, \"Click me\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"f5614124-e84d-52f7-91d0-938a5e111ce2","fields":{"slug":"/react-rerender/"},"frontmatter":{"title":"When Does React Rerender Components?"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"When Does React Rerender Components?\",\n  \"date\": \"2018-09-10\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"React is known for its performance. Because it has a virtual DOM and only updates the real DOM when required it can be much faster than updating the DOM all the time, even to display the same information. However, React\\u2019s \\u201Csmarts\\u201D only go so far (at the moment!), and it\\u2019s our job to know its expectations and limitations so we don\\u2019t accidentally hurt performance.\"), mdx(\"p\", null, \"One of the aspects we need to be aware of is how React decides when to re-render a component. Not as in \\u201Cupdate the DOM render,\\u201D but just to call the render method to change the virtual DOM. We can help React out by telling it when it should and shouldn\\u2019t render. Let\\u2019s look at both of those in turn\\u2026\"), mdx(\"h3\", null, \"The component\\u2019s state changes\"), mdx(\"p\", null, \"A re-render can only be triggered if a component\\u2019s state has changed. The state can change from a props change, or from a direct setState change. The component gets the updated state and React decides if it should re-render the component. Unfortunately, by default React is incredibly simplistic and basically re-renders everything all the time.\"), mdx(\"p\", null, \"Component changed? Re-render. Parent changed? Re-render. Section of props that doesn\\u2019t actually impact the view changed? Re-render.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"class Todo extends React.Component {\\n  componentDidMount() {\\n    setInterval(() => {\\n      this.setState(() => {\\n        console.log('setting state')\\n        return 'nothing'\\n      })\\n    }, 1000)\\n  }\\n\\n  render() {\\n    console.log('render called')\\n    return <div>...</div>\\n  }\\n}\\n\")), mdx(\"p\", null, \"In this (massively contrived) example the Todo will re-render every second, even though the render method doesn\\u2019t use unseen at all. In fact, unseen doesn\\u2019t even change its value! You can check out a working version of this on CodePen.\"), mdx(\"p\", null, \"Well, but re-rendering all the time isn\\u2019t helpful\\u2026\"), mdx(\"p\", null, \"I mean, I appreciate that React is being super careful. It would be worse if the state changed and the component didn\\u2019t render when it was supposed to. How would I know about that new message my friend sent me?! I\\u2019d miss it, so she\\u2019d probably assume it was intentional, then she\\u2019d stop talking to me, and the whole friendship would be ruined. All for the want of a little green dot not re-rendering. High stakes. Re-rendering is definitely the safe option.\"), mdx(\"p\", null, \"But re-rendering seems expensive (and your example is melodramatic)\"), mdx(\"p\", null, \"Yes, re-rendering unnecessarily does waste cycles and is generally not a good idea. However, React can\\u2019t \\u201Cjust know\\u201D when it\\u2019s safe to ignore parts of the state. So it plays it safe and re-renders whenever there\\u2019s a change to the state, important or not.\"), mdx(\"p\", null, \"How can we tell React to skip re-rendering?\"), mdx(\"h3\", null, \"shouldComponentUpdate method\"), mdx(\"p\", null, \"By default, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" returns true. That\\u2019s what causes the \\u201Cupdate everything all the time\\u201D we saw above. However, you can overwrite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" to give it more \\u201Csmarts\\u201D if you need the performance boost. Instead of letting React re-render all the time, you can tell React when you don\\u2019t want to trigger a re-render.\"), mdx(\"p\", null, \"When React comes to render the component it will run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" and see if it returns true (the component should update, a.k.a. re-render) or false (React can skip the re-render this time). So you\\u2019ll need to overwrite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" to return true or false as needed to tell React when to re-render and when to skip.\"), mdx(\"p\", null, \"When you use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" you\\u2019ll need to decide which bits of data actually matter for the re-render. Let\\u2019s go back to our example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"class Todo extends React.Component {\\n  componentDidMount() {\\n    setInterval(() => {\\n      this.setState(() => {\\n        console.log('setting state')\\n        return 'nothing'\\n      })\\n    }, 1000)\\n  }\\n\\n  shouldComponentUpdate(nextProps) {\\n    const hasDifferentTitle = this.props.title !== nextProps.title\\n    const hasDifferentDone = this.props.done !== nextProps.done\\n    return hasDifferentTitle || hasDifferentDone\\n  }\\n\\n  render() {\\n    console.log('render called')\\n    return <div>...</div>\\n  }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}}}}