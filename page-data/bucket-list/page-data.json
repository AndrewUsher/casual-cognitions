{"componentChunkName":"component---src-templates-blog-post-js","path":"/bucket-list/","webpackCompilationHash":"352f8472a14b4023922c","result":{"data":{"site":{"siteMetadata":{"title":"Casual Cognitions","author":"Andrew Usher"}},"mdx":{"frontmatter":{"title":"Bucket List","date":"September 20, 2018"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Bucket List\",\n  \"date\": \"2018-09-20\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"South Park Escape Room\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"See the Mona Lisa\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Visit a Castle\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Go On A Cruise\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fly In A Helicopter\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Meet Dan Abramov\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fly First Class\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Live In A Different Country\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fly a Kite\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Grow A Tree\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Backpack to 10 Places\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Run A Marathon\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Take Part in Triathlon\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Go Scuba Diving\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Walk the Inca Trail\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Climb a Mountain\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fly in A Hot Air Balloon\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Volcano Boarding\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Go to Google Headquarters\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/bucket-list/","previous":{"id":"f5614124-e84d-52f7-91d0-938a5e111ce2","fields":{"slug":"/react-rerender/"},"frontmatter":{"title":"When Does React Rerender Components?"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"When Does React Rerender Components?\",\n  \"date\": \"2018-09-10\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"React is known for its performance. Because it has a virtual DOM and only updates the real DOM when required it can be much faster than updating the DOM all the time, even to display the same information. However, React\\u2019s \\u201Csmarts\\u201D only go so far (at the moment!), and it\\u2019s our job to know its expectations and limitations so we don\\u2019t accidentally hurt performance.\"), mdx(\"p\", null, \"One of the aspects we need to be aware of is how React decides when to re-render a component. Not as in \\u201Cupdate the DOM render,\\u201D but just to call the render method to change the virtual DOM. We can help React out by telling it when it should and shouldn\\u2019t render. Let\\u2019s look at both of those in turn\\u2026\"), mdx(\"h3\", null, \"The component\\u2019s state changes\"), mdx(\"p\", null, \"A re-render can only be triggered if a component\\u2019s state has changed. The state can change from a props change, or from a direct setState change. The component gets the updated state and React decides if it should re-render the component. Unfortunately, by default React is incredibly simplistic and basically re-renders everything all the time.\"), mdx(\"p\", null, \"Component changed? Re-render. Parent changed? Re-render. Section of props that doesn\\u2019t actually impact the view changed? Re-render.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"class Todo extends React.Component {\\n  componentDidMount() {\\n    setInterval(() => {\\n      this.setState(() => {\\n        console.log('setting state')\\n        return 'nothing'\\n      })\\n    }, 1000)\\n  }\\n\\n  render() {\\n    console.log('render called')\\n    return <div>...</div>\\n  }\\n}\\n\")), mdx(\"p\", null, \"In this (massively contrived) example the Todo will re-render every second, even though the render method doesn\\u2019t use unseen at all. In fact, unseen doesn\\u2019t even change its value! You can check out a working version of this on CodePen.\"), mdx(\"p\", null, \"Well, but re-rendering all the time isn\\u2019t helpful\\u2026\"), mdx(\"p\", null, \"I mean, I appreciate that React is being super careful. It would be worse if the state changed and the component didn\\u2019t render when it was supposed to. How would I know about that new message my friend sent me?! I\\u2019d miss it, so she\\u2019d probably assume it was intentional, then she\\u2019d stop talking to me, and the whole friendship would be ruined. All for the want of a little green dot not re-rendering. High stakes. Re-rendering is definitely the safe option.\"), mdx(\"p\", null, \"But re-rendering seems expensive (and your example is melodramatic)\"), mdx(\"p\", null, \"Yes, re-rendering unnecessarily does waste cycles and is generally not a good idea. However, React can\\u2019t \\u201Cjust know\\u201D when it\\u2019s safe to ignore parts of the state. So it plays it safe and re-renders whenever there\\u2019s a change to the state, important or not.\"), mdx(\"p\", null, \"How can we tell React to skip re-rendering?\"), mdx(\"h3\", null, \"shouldComponentUpdate method\"), mdx(\"p\", null, \"By default, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" returns true. That\\u2019s what causes the \\u201Cupdate everything all the time\\u201D we saw above. However, you can overwrite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" to give it more \\u201Csmarts\\u201D if you need the performance boost. Instead of letting React re-render all the time, you can tell React when you don\\u2019t want to trigger a re-render.\"), mdx(\"p\", null, \"When React comes to render the component it will run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" and see if it returns true (the component should update, a.k.a. re-render) or false (React can skip the re-render this time). So you\\u2019ll need to overwrite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" to return true or false as needed to tell React when to re-render and when to skip.\"), mdx(\"p\", null, \"When you use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldComponentUpdate\"), \" you\\u2019ll need to decide which bits of data actually matter for the re-render. Let\\u2019s go back to our example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"class Todo extends React.Component {\\n  componentDidMount() {\\n    setInterval(() => {\\n      this.setState(() => {\\n        console.log('setting state')\\n        return 'nothing'\\n      })\\n    }, 1000)\\n  }\\n\\n  shouldComponentUpdate(nextProps) {\\n    const hasDifferentTitle = this.props.title !== nextProps.title\\n    const hasDifferentDone = this.props.done !== nextProps.done\\n    return hasDifferentTitle || hasDifferentDone\\n  }\\n\\n  render() {\\n    console.log('render called')\\n    return <div>...</div>\\n  }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"711ea32c-a5fb-51c1-a259-e7f0bacf919f","fields":{"slug":"/setstate-function/"},"frontmatter":{"title":"setState: a function??"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"setState: a function??\",\n  \"date\": \"2018-10-19\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Components in React are independent and reusable pieces of code that often contain their own state. They return React elements that make up the UI of an application. Components that contain local state have a property called state When we want to change our how application looks or behaves, we need to change our component\\u2019s state. So, how do we update the state of our component? React components have a method available to them called setState Calling this.setState causes React to re-render your application and update the DOM.\"), mdx(\"p\", null, \"Normally, when we want to update our component we just call setState with a new value by passing in an object to the setState function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"this.setState({ someField: someValue })\\n\")), mdx(\"p\", null, \"But, often there is a need to update our component\\u2019s state using the current state of the component. Directly accessing this.state to update our component is not a reliable way to update our component\\u2019s next state. From the React documentation:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.\")), mdx(\"p\", null, \"The key word from that documentation is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"asynchronously\"), \". Updates to the DOM don\\u2019t happen immediately when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this.setState\"), \" is called. React batches updates so elements are re-rendered to the DOM efficiently.\"), mdx(\"h3\", null, \"Function in setState!\"), mdx(\"p\", null, \"Instead of passing in an object to this.setState we can pass in a function and reliably get the value of the current state of our component:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"this.setState(prevState => ({\\n  someBool: !prevState.someBool,\\n}))\\n\")), mdx(\"p\", null, \"Passing in a function into setState instead of an object will give you a reliable value for your component\\u2019s state and props. If you know you\\u2019re going to use setState to update your component and you know you\\u2019re going to need the current state or the current props of your component to calculate the next state, passing in a function as the first parameter of this.setState instead of an object is the recommended solution.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}}}}