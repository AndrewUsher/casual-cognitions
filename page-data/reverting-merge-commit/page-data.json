{"componentChunkName":"component---src-templates-blog-post-js","path":"/reverting-merge-commit/","webpackCompilationHash":"115c318475c32b7c029a","result":{"data":{"site":{"siteMetadata":{"title":"Casual Cognitions","author":"Andrew Usher"}},"mdx":{"frontmatter":{"title":"Reverting A Merge Commit","date":"January 23, 2019"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Reverting A Merge Commit\",\n  \"date\": \"2019-01-23\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Oh dear. This is going to get complicated.To create an positive commit to remove the effects of a merge commit, you must first identify the SHA of the commit you want to revert. You can do this using\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gitk --date-order\"), \"\\xA0or using\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git log --graph --decorate --oneline\")), mdx(\"p\", null, \"You are looking for the 40 character SHA-1 hash ID (or the 7 character abbreviation). Yes, if you know the \\u201D^\\u201D or \\u201D~\\u201D shortcuts you may use those.Undoing the file modifications caused by the merge is about as simple as you might hope.\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git revert -m 1 SHA\"), \". (replace \\u201CSHA\\u201D with the reference you want to revert;\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-m 1\"), \"\\xA0will revert changes from all but the first parent, which is almost always what you want.) Unfortunately, this is just the tip of the iceberg.\"), mdx(\"p\", null, \"The problem is, what happens months later, long after you have exiled this problem from your memory, when you try again to merge these branches (or any other branches they have been merged into)? Because git has it tracked in history that a merge occurred, it is not going to attempt to remerge what it has already merged, and even worse, if you merge\\xA0\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"from\"), \"\\xA0the branch where you did the revert you will undo the changes on the branch where they were made. (Imagine you revert a premature merge of a long-lived topic branch into master and later merge master into the topic branch to get other changes for testing.)One option is actually to do this reverse merge immediately, annihilating any changes before the bad merge, and then to \\u201Crevert the revert\\u201D to restore them. This leaves the changes removed from the branch you mistakenly merged to, but present on their original branch, and allows merges in either direction without loss. This is the simplest option, and in many cases, can be the best.A disadvantage of this approach is that\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git blame\"), \"\\xA0output is not as useful (all the changes will be attributed to the revert of the revert) and\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git bisect\"), \"\\xA0is similarly impaired. Another disadvantage is that you must merge all current changes in the target of the bad merge back into the source; if your development style is to keep branches clean, this may be undesirable, and if you rebase your branches (e.g. with\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git pull --rebase\"), \"), it could cause complications unless you are careful to use\\xA0\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"git rebase -p\"), \"\\xA0to preserve merges.In the following example please replace $destination with the name of the branch that was the destination of the bad merge, $source with the name of the branch that was the source of the bad merge, and $sha with the SHA-1 hash ID of the bad merge itself.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sh\"\n  }), \"git checkout $destination\\ngit revert $sha\\n# save the SHA-1 of the revert commit to un-revert it later\\nrevert=`git rev-parse HEAD`\\ngit checkout $source\\ngit merge $destination\\ngit revert $revert\\n\")), mdx(\"p\", null, \"Another option is to abandon the branch you merged from, recreate it from the previous merge-base with the commits since then rebased or cherry-picked over, and use the recreated branch from now on. Then the new branch is unrelated and will merge properly. Of course, if you have pushed the donor branch you cannot use the same name (that would be rewriting public history and is bad) so everyone needs to remember to use the new branch. Hopefully you have something like\\xA0\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/sitaramc/gitolite\"\n  }), \"gitolite\"), \"\\xA0where you can close the old branch name.\"), mdx(\"p\", null, \"This approach has the advantage that the recreated donor branch will have cleaner history, but especially if there have been many commits (and especially merges) to the branch, it can be a lot of work. At this time, I will not walk you through the process of recreating the donor branch. Given sufficient demand I can try to add that. However, if you look at\\xA0\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.txt\"\n  }), \"howto/revert-a-faulty-merge.txt\"), \"\\xA0(also shipped as part of the git distribution) it will provide more words than you can shake a stick at.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/reverting-merge-commit/","previous":{"id":"62e37487-1730-59e8-9943-b2e6a6634f11","fields":{"slug":"/react-aha-moments/"},"frontmatter":{"title":"React Aha Moments"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React Aha Moments\",\n  \"date\": \"2019-01-22\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How using immutable objects as props can make \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"shouldComponentUpdate\"), \" super fast for pure components, even when you need complicated hierarchical objects\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"That \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"render\"), \" function is called before \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"componentDidMount\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You don\\u2019t need to have any data-flow package (flux, redux, mobx, etc) unless your components need to share state\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Your UI is a function of your state\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"That when two components need to share state I need to lift it up instead of trying to keep their states in sync\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Components don\\u2019t necessarily have to correspond to DOM nodes\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"a33f7a74-dda3-56e5-a5f3-68d230b4ad80","fields":{"slug":"/use-window-size/"},"frontmatter":{"title":"useWindowSize"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"useWindowSize\",\n  \"date\": \"2019-02-06\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A really common need is to get the current size of the browser window. This hook returns an object containing the window\\u2019s width and height. If executed server-side (no window object) the value of width and height will be undefined.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import { useState, useEffect } from 'react'\\n\\nconst Example = () => {\\n  const { height, width } = useWindowSize()\\n\\n  return (\\n    <div>\\n      {width}px / {height}px\\n    </div>\\n  )\\n}\\n\\n// Hook\\nfunction useWindowSize() {\\n  const isBrowser = typeof window !== 'undefined'\\n\\n  const getSize = () => ({\\n    width: isBrowser ? window.innerWidth : undefined,\\n    height: isBrowser ? window.innerHeight : undefined,\\n  })\\n\\n  const handleResize = () => {\\n    setWindowSize(getSize())\\n  }\\n\\n  const [windowSize, setWindowSize] = useState(getSize)\\n\\n  useEffect(() => {\\n    if (!isBrowser) return\\n    window.addEventListener('resize', handleResize)\\n    return () => window.removeEventListener('resize', handleResize)\\n  }, [])\\n\\n  return windowSize\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}}}}